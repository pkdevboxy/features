import org.gradle.platform.base.internal.PlatformResolvers
import org.gradle.platform.base.internal.DefaultPlatformRequirement

@Managed
interface MyAndroidPlatform extends Platform {
    @Unmanaged
    JavaPlatform getJavaPlatform()
    void setJavaPlatform(JavaPlatform javaPlatform)
}

@Managed
interface MyAndroidLibrarySpec extends ComponentSpec {
}

// It would be nice if Android software model developers could define their own classes directory concept
// This would require managed subtypes of `BuildableModelElement`, I think
@Managed
interface MyClassesDirectory extends ClassesDirectory {
}

@Managed
interface MyAndroidVariantSpec extends BinarySpec,
                                       HasClassesDirectory<MyClassesDirectory>,
                                       HasTargetPlatform<MyAndroidPlatform> {
}

class MyAndroidPlugin extends RuleSource {

    // TODO: Decide on a reasonable public way to resolve `JavaPlatform` instances
    @Model
    void androidPlatforms(ModelMap<MyAndroidPlatform> platforms, PlatformResolvers platformResolvers) {
        def javaPlatformFor = { name ->
            platformResolvers.resolve(JavaPlatform, DefaultPlatformRequirement.create(name))
        }
        platforms.create("androidOnJava6") {
            javaPlatform = javaPlatformFor("java6")
        }
        platforms.create("androidOnJava7") {
            javaPlatform = javaPlatformFor("java7")
        }
    }

    @Mutate
    void createDefaultSourceSetsForAndroidLibrary(ModelMap<MyAndroidLibrarySpec> components) {
        components.beforeEach(new Action<MyAndroidLibrarySpec>() {
            @Override
            void execute(MyAndroidLibrarySpec componentSpec) {
                componentSpec.sources.create("java", JavaSourceSet)
            }
        })
    }

    // TODO: This feature could use a rule that targets the sources for every component of a type
    /*
    @Defaults
    void defaultSourceSets(@Path("components", MyAndroidLibrarySpec, "sources") ModelMap<LanguageSourceSet> sources) {
        sources.create("java", JavaSourceSet)
    }
    */

    @ComponentBinaries
    void createAndroidVariantPerPlatform(ModelMap<MyAndroidVariantSpec> variantSpecs,
                                         MyAndroidLibrarySpec librarySpec,
                                         ModelMap<MyAndroidPlatform> platforms) {
        for (MyAndroidPlatform platform : platforms) {
            variantSpecs.create("${librarySpec.name}For${platform.name.capitalize()}") {
                ///*
                targetPlatform = platform
                classesDirectory {
                    javaPlatform = platform.javaPlatform
                }
                //*/
            }
        }
    }
}

plugins {
    id 'jvm-component'
    id 'java-lang'
}

//apply plugin: MyAndroidPlugin

model {
    components {
        myAndroidLib(MyAndroidLibrarySpec)
    }
}

// ----

interface HasClassesDirectory<T extends ClassesDirectory> {
    T getClassesDirectory()
    void setClassesDirectory(T classesDirectory)
}

interface HasTargetPlatform<T extends Platform> {
    T getTargetPlatform()
    void setTargetPlatform(T targetPlatform)
}

interface ClassesDirectory {
}
