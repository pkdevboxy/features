@Managed
interface MyAndroidPlatform extends Platform, WithJavaPlatform {
}

@Managed
interface MyAndroidLibrarySpec extends ComponentSpec {
}

@Managed
interface MyAndroidVariantSpec extends BinarySpec, WithJvmAssembly {
}

class MyAndroidPlugin extends RuleSource {
    // TODO: Decide on a reasonable public way to resolve `JavaPlatform` instances
    @Model
    void androidPlatforms(ModelMap<MyAndroidPlatform> platforms, PlatformResolvers platformResolvers) {
        def javaPlatformFor = { name ->
            platformResolvers.resolve(JavaPlatform, DefaultPlatformRequirement.create(name))
        }
        platforms.create("androidOnJava6") {
            javaPlatform = javaPlatformFor("java6")
        }
        platforms.create("androidOnJava7") {
            javaPlatform = javaPlatformFor("java7")
        }
    }

    @Mutate
    void createDefaultSourceSetsForAndroidLibrary(ModelMap<MyAndroidLibrarySpec> components) {
        components.beforeEach(new Action<MyAndroidLibrarySpec>() {
            @Override
            void execute(MyAndroidLibrarySpec componentSpec) {
                componentSpec.sources.create("java", JavaSourceSet)
                componentSpec.sources.create("resources", JvmResourceSet)
            }
        })
    }

    @ComponentBinaries
    void createAndroidVariantPerPlatform(ModelMap<MyAndroidVariantSpec> variantSpecs,
                                         MyAndroidLibrarySpec librarySpec,
                                         ModelMap<MyAndroidPlatform> platforms,
                                         @Path("buildDir") File buildDir) {
        for (MyAndroidPlatform platform : platforms) {
            variantSpecs.create("${librarySpec.name}For${platform.name.capitalize()}") {
                // TODO: DefaultJvmAssembly instantiation should happen automatically
                assembly = new DefaultJvmAssembly()
                assembly.targetPlatform = platform
                assembly.classDirectories << namingScheme.getOutputDirectory(buildDir, "classes")
                assembly.resourceDirectories << namingScheme.getOutputDirectory(buildDir, "resources")
            }
        }
    }
}

plugins {
    id 'jvm-component'
    id 'java-lang'
}

apply plugin: MyAndroidPlugin

model {
    components {
        myAndroidLib(MyAndroidLibrarySpec)
    }
}

// ----
// Provided by Gradle

/**
 * Declares the {@link JavaPlatform} of an extended platform.
 */
@Managed
interface WithJavaPlatform extends Platform {
    @Unmanaged
    JavaPlatform getJavaPlatform()
    void setJavaPlatform(JavaPlatform javaPlatform)
}

/**
 * Declares the {@link JvmAssembly} of a variant.
 */
@Managed
interface WithJvmAssembly {
    @Unmanaged
    JvmAssembly getJvmAssembly()
}

/**
 * The smallest unit of deployment of a JVM component:
 *  - a set of directories containing class files
 *  - a set of directories containing resource files
 */
interface JvmAssembly extends BuildableModelElement {
    /**
     * Set of directoring containing the class files that
     * belong to this assembly.
     *
     * Modeled as a Set<File> for future proofnes but the
     * first implementation can assume a single class directory.
     */
    Set<File> getClassDirectories()

    /**
     * Set of directories containing the resource files that
     * belong to this assembly.
     */
    Set<File> getResourceDirectories()

    /**
     * Returns the {@link org.gradle.jvm.toolchain.JavaToolChain} that will be used to build this assembly.
     */
    JavaToolChain getToolChain();

    /**
     * The target platform for this assembly.
     */
    JavaPlatform getTargetPlatform();
}

// Not part of the API
class DefaultJvmAssembly extends AbstractBuildableModelElement implements JvmAssembly {
    Set<File> classDirectories
    Set<File> resourceDirectories
    JavaPlatform targetPlatform
    JavaToolChain toolChain

    DefaultJvmAssembly() {
        classDirectories = new HashSet<File>()
        resourceDirectories = new HashSet<File>()
    }
}

// TODO: Decide on a reasonable public way to resolve `JavaPlatform` instances
import org.gradle.api.internal.*
import org.gradle.platform.base.internal.*
