# Developer builds a Play application

- [x] Build author declares and builds a Play application component
- [x] Developer builds a basic Play application
- [x] Developer configures Scala sources for Jvm library
- [x] Developer configures Scala sources and Jvm resources for Play application
- [x] Developer configures template sources for Play application
- [x] Developer defines routes for Play application
- [x] Developer includes static assets in Play application
- [x] Developer includes compiled coffeescript assets in Play application
- [x] Developer uses minified javascript assets in Play application
- [x] Developer configures dependencies for Play application
- [x] Scala compiler daemons synchronize the creation of Zinc compiler
- [ ] Developer configures template sources using java imports

#### Later features and stories

- Better dependency management for Play applications
    - Story: Developer adds default Play repositories to build script
- Feature: Build author provides plugin for asset processing in Play application (Javascript, LESS, CoffeeScript)
    - Developer includes other processed asset types in Play application
- Scala code quality plugins
- Javascript plugins
- Bootstrap a new Play project via `gradle init`

## Stories

### Story: Build author declares and builds a Play application component

Add a `play-application` plugin that provides Play application component:

```gradle
plugins {
    id 'play-application'
}

model {
    components {
        myapp(PlayApplicationSpec)
    }
}
```

- ~~Running `gradle assemble` builds an empty Jar file.~~
- ~~Running `gradle components` shows some basic details about the Play application.~~
- In this story, no source files are supported.

#### Test cases

- ~~component report shows PlayApplicationSpec with~~
- ~~version info about~~
      - ~~play  (declared in the plugin)~~
      - ~~java  (picked current version for now)~~
- ~~assemble creates an empty jar file~~

### Story: Developer builds a basic Play application

When running `gradle assemble`, a Jar file will be built for the default template application generated by Play.

- Using hard-coded:
    - Locations of java/scala files
    - Locations of routes file
    - Locations of templates files
    - Scala version
    - Dependencies of Play ("com.typesafe.play:play_2.11:2.3.7")
    - Dependency of template compiler ("com.typesafe.play:twirl-compiler_2.11:1.0.2)
    - Dependency of routes compiler
- resolve different play dependencies from user-configured repositories

#### Implementation

- setup TwirlCompiler task type
- setup RoutesCompiler task type
- Compile routes to scala and java
- Compile templates to scala
- Compile all scala (app/\*/\*.{scala,java}, output of: conf/routes, output of: app/views/\*.scala.html) files
- Output class files are part of assemble jar file

#### Test cases

- verify that generated scala template files exists
- verify that generated scala/java route files exists
- `gradle assemble` should trigger compile task and output jar should contain class files

### Story: Developer configures Scala sources for Jvm library

Add a new 'scala-lang' plugin to add Scala language support implemented in the same manner as the JavaLanguagePlugin.

```gradle
plugins {
    id 'jvm-component'
    id 'scala-lang'
}
model {
    components {
        myLib(JvmLibrarySpec)
        myOtherLib(JvmLibrarySpec) {
            sources {
                scala {
                    source.srcDir "src/myOtherLib/myScala"
                }
                otherScala(ScalaSourceSet) {
                    source.srcDir "src/otherScala"
                }
            }
        }
    }
}
```

##### Test cases

- Scala source set(s) and locations are visible in the components report
- Uses scala sources from conventional location
- Can configure location of scala sources
- Build is incremental:
    - Changed in Scala comment does not result in rebuilding JVM library
    - Change in Scala compile properties triggers recompilation
    - Change in Scala platform triggers recompilation
    - Change in Scala ToolChain triggers recompilation
    - Removal of Scala source files removes classes for that source file, which are removed from JVM library
- Compile is incremental: consider sources A, B, C where B depends on C
    - Change A, only A is recompiled
    - Change B, only B is recompiled
    - Change C, only B & C are recompiled
    - Remove A, outputs for A are removed
- Can include both Java and Scala sources in lib: no cross-compilation

### Story: Developer configures Scala sources and Jvm resources for Play application

Extend the Play support to full model Scala sources and Jvm resources.

- A default ScalaLanguageSourceSet 'scala' will include java and scala source files in `app/controllers` and `app/models`.
- A default JvmResourceSet 'resources' will include files in `public` and `conf`
- Files can be included/excluded in the default source sets
- Additional source sets can be configured
- All source sets are listed in the component report for a play application
- All Scala source sets in a Play application are joint-compiled

```gradle
plugins {
    id 'play-application'
}
model {
    components {
        play(PlayApplicationSpec) {
            sources {
                scala {
                    source.include "extraStuff/**"
                }
                resources {
                    source.srcDir "src/assets"
                }
                extraScala(ScalaLanguageSourceSet) {
                    source.srcDir "src/extraScala"
                }
            }
        }
    }
}
```

#### Test cases

- Scala and Jvm source sets (and locations) are visible in the components report
- Can configure additional includes and/or source directories for default `scala` and `resources` source sets
- Can provide an additional Scala source set for a Play application, with dependencies on main sources
- Can provide an additional resources set for a Play application
- Build is incremental:
    - Changed in Scala comment does not result in rebuilding Play app
    - Change in Scala or Java source file triggers recompilation
    - Change in Scala or Java compile properties triggers recompilation
    - Change in Platform triggers recompilation
    - Change in ToolChain triggers recompilation
    - Removal of Scala/Java source files removes classes from the Play app

#### Open issues

- Use `LanguageTransform` from `scala-lang` plugin to configure scala compile task for source sets
- Use source set dependencies to determine of source sets should be joint compiled

### Story: Developer configures template sources for Play application

Add a TwirlSourceSet and permit multiple instances in a Play application

- Twirl sources show up in component report
- Allow Twirl source location to be configured
- Allow additional Twirl source sets to be configured
- Define a generated ScalaSourceSet as the output for each TwirlSourceSet compilation
    - Generated ScalaSourceSet will be one of the Scala compile inputs
    - Generated ScalaSourceSet should not be visible in components report
- Source generation and compilation should be incremental and remove stale outputs.

#### Open issues

- handle non html templates
- Ability for Twirl compiler to prefer Java types in generated sources (i.e. SBT enablePlugins(PlayJava))
- Verify that default imports are configured: https://github.com/playframework/playframework/blob/master/framework/src/build-link/src/main/java/play/TemplateImports.java
- Allow Twirl to be used in a non-play project

### Story: Developer defines routes for Play application

Add a RoutesSourceSet and permit multiple instances in a Play application

- Routes sources show up in component report
- Allow Routes source location to be configured
- Allow additional Routes source sets to be configured
- Define a generated ScalaSourceSet as the output for each RoutesSourceSet compilation
    - Generated ScalaSourceSet will be one of the Scala compile inputs
    - Generated ScalaSourceSet should not be visible in components report
- Source generation and compilation should be incremental and remove stale outputs.

#### Open issues

- handle .routes files
- Ability for Routes compiler to prefer Java types in generated sources (i.e. SBT enablePlugins(PlayJava))


### Story: Developer includes static assets in Play application

Any files under `/public` in the application sources are available under `/assets` in the running application.

### Story: Developer includes compiled coffeescript assets in Play application

Add a coffee script plugin as well as JavaScriptSourceSet and CoffeeScriptSourceSets and permit multiple instances.

```gradle
plugins {
    id 'play-application'
    id 'play-coffeescript'
}

model {
    components {
        play(PlayApplicationSpec) {
            sources {
                extraCoffeeScript(CoffeeScriptSourceSet) {
                    sources.srcDir "src/extraCoffeeScript"
                }

                extraJavaScript(JavaScriptSourceSet) {
                    sources.srcDir "src/extraJavaScript"
                }
            }
        }
    }
}
```

- Default coffeescript sourceset should be "app/assets/\*\*/\*.coffee"
- Compiled coffeescript files will be added to the jar under "public"
- Default javascript sourceset should be "app/assets/\*\*/\*.js"
- Processed javascript sourceset should be added to the jar under "public"

#### Test cases
- Coffeescript and javascript sources are visible in the components report
- Coffeescript sources successfully compiled to javascript
- Compiled coffeescript is added to jar under "public"
- Javascript sources are copied directly into jar under "public"
- Can provide additional coffeescript sources
- Can provide additional javascript sources
- Build is incremental:
    - Change in coffeescript source triggers recompile
    - No change in coffeescript source does not trigger a recompile
    - Removal of generated javascript triggers recompile
    - Removal of coffeescript source files removes generated javascript

### Story: Developer uses minified javascript assets in Play application

Extend the basic JavaScript plugin to include minified javascript assets in the Play application.
Use the Google Closure Compiler to produce a minified version of all Javascript assets. The minified files
should be named `<original-name>.min.<original-extension>` (usually the extension will be `.js`).

```gradle
plugins {
    id 'play'
}

model {
    components {
        play(PlayApplicationSpec) {
            sources {
                extraJavaScript(JavaScriptSourceSet) {
                    sources.srcDir "src/extraJavaScript"
                }
            }
        }
    }
}
```

#### Test cases
- Any javascript file in `app/assets` is available in minified form in the app.
- Any javascript file in a configured JavaScriptSourceSet is available in minified form in the app.
- Any compiled coffeeScript source file is available in both non-minified and minified javascript forms.
- Build is incremental:
    - Minifier is not executed when no source inputs have changed
    - Changed javascript source produces changed minified javasript
    - Changed coffeescript source produces changed minified javascript
    - Removal of javascript source removes minified javascript
    - Removal of coffeescript source removes both minified and non-minified javascript

### Scala compiler daemons synchronize the creation of Zinc compiler objects
When a Zinc compiler is instantiated, it tries to create a jar file under the Zinc cache directory.  By default,
this cache directory is ~/.zinc.  Once the jar file is created, it does not create it again unless there is a change
in scala or java version.  But if several compilers are created when the jar file does not exist, multiple compilers
can try to create the jar file at the same time or a compiler can try to use the jar file before another compiler has
finished creating it.  This results in ClassDefNotFound errors from the compile task.

We need to do the following:
- Synchronize the creation of Zinc compiler objects across all builds on a system so that only one compiler
object tries to create the jar file and others do not attempt to use it until the file is fully created.
- Change the Zinc cache dir to use a cache directory under GRADLE_USER_HOME in a Gradle version-specific directory so
that it won't conflict with other non-Gradle Zinc compilers.
- Use the existing CacheRepository capability to manage access to the Zinc cache dir.

Test cases:
- compiler-interface.jar is created under GRADLE_USER_HOME after a scala compile and not under ~/.zinc.
- Multiple Scala compile tasks succeed under the following scenarios (when compiler-interface.jar both exists and not):
    - Multiple single project builds running concurrently
    - Multiproject build with --parallel
    - Single project build with intra-project parallelization enabled
- User setting the "zinc.dir" system property on the compile task does not have an effect (we still use the GRADLE_USER_HOME
directory) and a warning is shown.

### Developer configures template sources using Java imports
By default, the Twirl compiler generates source files assuming the template files expect Scala imports.  The developer may,
however, write their template files expecting Java imports instead.  This is exposed as a switch on the Twirl compiler.  This
story models this switch on the Twirl source set to signify that a given source set expects Java imports instead.

```gradle
model {
    components {
        play(PlayApplicationSpec) {
            sources {
                extraTwirl(TwirlSourceSet) {
                    defaultImports = TwirlImports.JAVA
                }
            }
        }
    }
}
```

Test cases:
- defaults to scala imports
- developer can configure the defaultImports to use Java imports
- configuring a source set to use Java imports causes play-java to be added to the classpath
- can configure source sets both with and without Java imports

## Later features and stories

### Developer adds default Play repositories to build script

This allows the developer to easily add repositories to the build script using a convenience extension on the RepositoryContainer object.

```gradle
buildscript {
    repositories {
        gradlePlay()
    }
}
```

This should point to a virtual repository (play-public) at gradle.repo.org that's backed by the default repositories required for play functionality.
Currently the following repositories would be required:
- https://repo.typesafe.com/typesafe/maven-releases (play support)
- https://repo.gradle.org/gradle/javascript-public (coffeescript and other javascript artifacts)

#### Test Cases
- Can build a basic play application using the convenience extension to specify repositories
- Can build a coffeescript-enabled play application using the convenience extension to specify repositories

### Build author provides plugin for asset processing in Play application (Javascript, LESS, CoffeeScript)

Extend the standard build lifecycle to compile the front end assets to CSS and Javascript.

- Provide some built-in implementations of asset plugins
    - Coffeescript -> Javascript
    - LESSCSS -> CSS
    - Javascript > Javascript via Google Closure
    - Javascript minification, requirejs optimization
- For built-in asset plugins
    - Build on public API
    - Include the compiled assets in the Jar
    - Define source sets for each type of source file
    - Compilation should be incremental and remove stale outputs
    - Expose some compiler options

#### Implementation

JavaScript language plugin:

- Defines JavaScript library component and associated JavaScript bundle binary.
- Defines JavaScript source set type (a JavaScript bundle and JavaScript source set should be usable in either role).
- Defines transformation from JavaScript source set to JavaScript bundle.

CSS language plugin:

- Defines CSS library component and associated CSS bundle binary.
- Defines CSS source set type (a CSS bundle and CSS source set should be usable in either role).
- Defines transformation from CSS source set to CSS bundle.

CoffeeScript plugin:

- Defines CoffeeScript source set type and transformation to JavaScript bundle.

LESSCSS plugin:

- Defines LESSCSS source set type and transformation to CSS bundle.

Google Closure plugin:

- Defines transformation from JavaScript source set to JavaScript bundle.

Play plugin:

- Defines JavaScript and CSS components for the Play application.
- Wires in the appropriate outputs to assemble the Jar.

#### Open issues

- Integration with existing Gradle javascript plugins.

### Scala code quality plugins

- Scalastyle
- SCCT

### Javascript plugins

- Compile Dust templates to javascript and include in the web application image

### Bootstrap a new Play project

Extend the build init plugin so that it can bootstrap a new Play project, producing the same output as `activator new` except with a Gradle build instead of
an SBT build.
